#Использовать fs
#Использовать 1commands
#Использовать tempfiles

Перем Лог;

///////////////////////////////////////////////////////////////////////////////////////////////////
// Прикладной интерфейс

Процедура ЗарегистрироватьКоманду(Знач ИмяКоманды, Знач Парсер) Экспорт
	
	ОписаниеКоманды = Парсер.ОписаниеКоманды(ИмяКоманды, "Проверка проекта EDT");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--junitpath", "Путь отчета в формате JUnit.xml");
	Парсер.ДобавитьПараметрФлагКоманды(ОписаниеКоманды, "--groupbymetadata",
	"Группировать проверки в junit по метаданным конфигурации");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--exception-file",
	"Путь файла с указанием пропускаемых исключений
	|	Формат файла: в каждой строке файла указан текст пропускаемого исключения или его часть
	|	Кодировка: UTF-8");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--workspace-location", "Расположение рабочей области");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--project-list", 
	"Необязательный аргумент. Список папок, откуда загрузить проекты в формате EDT для проверки.
	|	Одновременно можно использовать только один агрумент: project-list или project-name-list");
	Парсер.ДобавитьИменованныйПараметрКоманды(ОписаниеКоманды, "--project-name-list",
	"Необязательный аргумент. Cписок имен проектов в текущей рабочей области, откуда загрузить проекты в формате EDT для проверки.
	|	Одновременно можно использовать только один агрумент: project-list или project-name-list.
	|
	|	Пример выполнения:
	|		vanessa-runner edt-validate --project-list D:/project-1 D:/project-2 --workspace-location D:/workspace
	|
	|	ВНИМАНИЕ! Параметры, которые перечислены далее, не используются.
	|
	|");
	
	Парсер.ДобавитьКоманду(ОписаниеКоманды);
	
КонецПроцедуры

// Выполняет логику команды
// 
// Параметры:
//   ПараметрыКоманды - Соответствие - Соответствие ключей командной строки и их значений
//   ДополнительныеПараметры - Соответствие -  (необязательно) дополнительные параметры
//
Функция ВыполнитьКоманду(Знач ПараметрыКоманды, Знач ДополнительныеПараметры = Неопределено) Экспорт
	
	Лог = ДополнительныеПараметры.Лог;
	// Лог.УстановитьУровень(УровниЛога.Отладка);
	
	ПутьОтчетаВФорматеJUnitxml = ПараметрыКоманды["--junitpath"];
	Если ПутьОтчетаВФорматеJUnitxml = Неопределено Тогда
		ПутьОтчетаВФорматеJUnitxml = "";
	КонецЕсли;
	
	РабочаяОбласть = ПараметрыКоманды["--workspace-location"];
	СписокПапокСПроектами = ПараметрыКоманды["--project-list"];
	СписокИменПроектов = ПараметрыКоманды["--project-name-list"];
	
	ИмяФайлаИсключенийОшибок = ПараметрыКоманды["--exception-file"];
	ГруппироватьПоМетаданным = ПараметрыКоманды["--groupbymetadata"];
	
	ДатаНачала = ТекущаяДата();
	
	ИмяФайлаРезультата = ПолучитьИмяВременногоФайла("out");
	
	Попытка
		
		Команда = Новый Команда;
		Команда.УстановитьКоманду( "ring edt workspace validate");
		Команда.УстановитьКодировкуВывода(КодировкаТекста.UTF8);
		Команда.ДобавитьПараметр( "--workspace-location " + РабочаяОбласть );
		Команда.ДобавитьПараметр( "--file " + ИмяФайлаРезультата );
		
		Если ЗначениеЗаполнено( СписокПапокСПроектами ) Тогда
			Команда.ДобавитьПараметр("--project-list " + СписокПапокСПроектами );
		КонецЕсли;
		
		Если ЗначениеЗаполнено( СписокИменПроектов ) Тогда
			Команда.ДобавитьПараметр("--project-name-list " + СписокИменПроектов );
		КонецЕсли;
		
		Команда.УстановитьИсполнениеЧерезКомандыСистемы(Ложь);
		Команда.ПоказыватьВыводНемедленно(Ложь);
		КодВозврата = Команда.Исполнить();
		
	Исключение
		УдалитьФайлы(ИмяФайлаРезультата);
		ВызватьИсключение ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Успешно = КодВозврата = 0;

	тзРезультат = ПрочитатьТаблицуИзФайлаРезультата( ИмяФайлаРезультата );

	УдалитьФайлы(ИмяФайлаРезультата);
	
	Если ЗначениеЗаполнено(ПутьОтчетаВФорматеJUnitxml) Тогда
		
		Лог.Отладка("Путь к лог-файлу проверки %1", ПутьОтчетаВФорматеJUnitxml);
		
		ФайлОтчетаВФорматеJUnitxml = Новый Файл(ОбъединитьПути(ТекущийКаталог(), ПутьОтчетаВФорматеJUnitxml));
		Лог.Отладка("Полный путь к лог-файлу проверки %1", ФайлОтчетаВФорматеJUnitxml.ПолноеИмя);
		Лог.Отладка("Каталог лог-файла проверки %1", ФайлОтчетаВФорматеJUnitxml.Путь);
		ФС.ОбеспечитьКаталог(ФайлОтчетаВФорматеJUnitxml.Путь);
		УдалитьФайлы(ФайлОтчетаВФорматеJUnitxml.ПолноеИмя);
		
		ВывестиОтчетПроверкиКонфигурацииВФорматеJUnitXML(ПутьОтчетаВФорматеJUnitxml, тзРезультат, 
			Успешно, ДатаНачала, ГруппироватьПоМетаданным, ИмяФайлаИсключенийОшибок);
		
		Лог.Информация("Сформированы результаты проверки в формате JUnit.xml - %1", ПутьОтчетаВФорматеJUnitxml);
		
	КонецЕсли;
	
	РезультатыКоманд = МенеджерКомандПриложения.РезультатыКоманд();

	Возврат ?(Успешно, РезультатыКоманд.Успех, РезультатыКоманд.ОшибкаВремениВыполнения);
	
КонецФункции

// { приватная часть 


Функция ПрочитатьТаблицуИзФайлаРезультата( Знач пПутьКФайлу )
	
	Лог.Отладка("Путь к файлу-результату проверки %1", пПутьКФайлу);

	тз = Новый ТаблицаЗначений;
	тз.Колонки.Добавить( "ДатаОбнаружения" );
	тз.Колонки.Добавить( "Тип" );
	тз.Колонки.Добавить( "Проект" );
	тз.Колонки.Добавить( "Метаданные" );
	тз.Колонки.Добавить( "Положение" );
	тз.Колонки.Добавить( "Описание" );
	
	ЧтениеТекста = Новый ЧтениеТекста( пПутьКФайлу , КодировкаТекста.UTF8);
	
	ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	
	Пока Не ПрочитаннаяСтрока = Неопределено Цикл
		
		Если ПустаяСтрока(ПрочитаннаяСтрока) Тогда
			Продолжить;
		КонецЕсли;
		
		компонентыСтроки = СтрРазделить( ПрочитаннаяСтрока, "	" );
		
		новСтрока = тз.Добавить();
		
		Для ц = 0 По 4 Цикл
			
			новСтрока[ц] = компонентыСтроки[ц];
			
		КонецЦикла;
		
		// В описании могут быть и табы, по которым делим
		
		Для ц = 5 По компонентыСтроки.ВГраница() Цикл
			
			Если ЗначениеЗаполнено( новСтрока.Описание ) Тогда
				новСтрока.Описание = новСтрока.Описание + "	";
			Иначе
				новСтрока.Описание = "";
			КонецЕсли;
			
			новСтрока.Описание = новСтрока.Описание + компонентыСтроки[ц];
			
		КонецЦикла;
		
		ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
		
	КонецЦикла;

	Лог.Отладка("Из файла-результата прочитано %1 строк", тз.Количество());

	Возврат тз;
	
КонецФункции

Процедура ВывестиОтчетПроверкиКонфигурацииВФорматеJUnitXML(Знач ПутьОтчетаВФорматеJUnitxml, 
	Знач тзРезультат, Знач НетОшибок, Знач ДатаНачала, Знач ГруппироватьПоМетаданным = Ложь,
	Знач ИмяФайлаИсключенийОшибок = Неопределено)
	
	ПредставлениеНабораТестов = ПредставлениеНабораТестов(ПутьОтчетаВФорматеJUnitxml);
	
	ИсключенияОшибок = СодержимоеФайлаИсключенийОшибок(ИмяФайлаИсключенийОшибок);
	
	Лог.Отладка("НетОшибок <%1>", НетОшибок);
	Если НетОшибок Тогда
		
		ЗаписьXML = НачатьЗаписьОтчета(ПредставлениеНабораТестов, 0, 0, ДатаНачала);
		ЗаписьXML.ЗаписатьКонецЭлемента(); // testcase
		
	Иначе
		
		ТестовыеСлучаи = СтруктурироватьЛог(тзРезультат, ГруппироватьПоМетаданным, ИсключенияОшибок);
		
		ЗаписьXML = НачатьЗаписьОтчета(
		ПредставлениеНабораТестов,
		ТестовыеСлучаи.Ошибки.Количество(),
		ТестовыеСлучаи.Предупреждения.Количество(),
		ТестовыеСлучаи.Пропуски.Количество(),
		ДатаНачала);
		
		// Если есть ошибки, добавим в отчет текст всех ошибок без группировки
		Если ТестовыеСлучаи.Ошибки.Количество() > 0 Тогда
			ЗаписьXML.ЗаписатьНачалоЭлемента("failure");
			ЗаписьXML.ЗаписатьАтрибут("message", XMLСтрока(ЛогПроверкиИзКонфигуратора));
			ЗаписьXML.ЗаписатьКонецЭлемента(); // failure
		КонецЕсли;
		
		ЗаписьXML.ЗаписатьКонецЭлемента(); // testcase summary
		
		Для Каждого ТекТестовыйСлучай Из ТестовыеСлучаи.Ошибки Цикл
			ЗаписьXML.ЗаписатьНачалоЭлемента("testcase");
			ЗаписьXML.ЗаписатьАтрибут("classname", СтрШаблон("%1.Ошибки", XMLСтрока(ПредставлениеНабораТестов)));
			ЗаписьXML.ЗаписатьАтрибут("name", XMLСтрока(ТекТестовыйСлучай.Ключ));
			ЗаписьXML.ЗаписатьАтрибут("status", "failure");
			
			ЗаписьXML.ЗаписатьНачалоЭлемента("failure");
			ЗаписьXML.ЗаписатьАтрибут("message", XMLСтрока(ТекТестовыйСлучай.Значение));
			ЗаписьXML.ЗаписатьКонецЭлемента(); // failure
			
			ЗаписьXML.ЗаписатьКонецЭлемента(); // testcase errors	
		КонецЦикла;
		
		Для Каждого ТекТестовыйСлучай Из ТестовыеСлучаи.Пропуски Цикл
			ЗаписьXML.ЗаписатьНачалоЭлемента("testcase");
			ЗаписьXML.ЗаписатьАтрибут("classname", СтрШаблон("%1.Пропуски", XMLСтрока(ПредставлениеНабораТестов)));
			ЗаписьXML.ЗаписатьАтрибут("name", XMLСтрока(ТекТестовыйСлучай.Ключ));
			ЗаписьXML.ЗаписатьАтрибут("status", "skipped");
			ЗаписьXML.ЗаписатьНачалоЭлемента("skipped");
			ЗаписьXML.ЗаписатьКонецЭлемента(); // skipped
			ЗаписьXML.ЗаписатьКонецЭлемента(); // testcase
		КонецЦикла;
		
	КонецЕсли;
	
	ЗаписьXML.ЗаписатьКонецЭлемента(); // testsuite
	
	ЗаписьXML.ЗаписатьКонецЭлемента(); // testsuites
	
	СтрокаХМЛ = ЗаписьXML.Закрыть();
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ПутьОтчетаВФорматеJUnitxml);
	ЗаписьXML.ЗаписатьБезОбработки(СтрокаХМЛ);// таким образом файл будет записан всего один раз, и не будет проблем с обработкой на билд-сервере TeamCity
	ЗаписьXML.Закрыть();
	
	Лог.Отладка("СтрокаХМЛ %1", СтрокаХМЛ);
	
КонецПроцедуры

Функция ПредставлениеНабораТестов(Знач ПутьОтчетаВФорматеJUnitxml)
	
	Если Не ЗначениеЗаполнено(ПутьОтчетаВФорматеJUnitxml) Тогда
		Возврат "CheckConfig";
	КонецЕсли;
	
	Файл = Новый Файл(ПутьОтчетаВФорматеJUnitxml);
	Возврат СтрШаблон("CheckConfig.%1", Файл.ИмяБезРасширения);
	
КонецФункции

Функция СодержимоеФайлаИсключенийОшибок(Знач ИмяФайлаИсключенийОшибок)
	
	Результат = Новый Массив;
	
	Если Не ЗначениеЗаполнено(ИмяФайлаИсключенийОшибок) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Лог.Отладка("Чтение файла исключений ошибок из %1", ИмяФайлаИсключенийОшибок);
	
	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайлаИсключенийОшибок, КодировкаТекста.UTF8);
	ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	Пока ПрочитаннаяСтрока <> Неопределено Цикл
		Если Не ПустаяСтрока(ПрочитаннаяСтрока) Тогда
			ДобавляемоеИсключение = НормализованныйТекстОшибки(ПрочитаннаяСтрока);
			Результат.Добавить(ДобавляемоеИсключение);
			Лог.Отладка("Добавлено в исключения: %1", ДобавляемоеИсключение);
		КонецЕсли;
		ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	КонецЦикла;
	
	Лог.Отладка("Прочитано исключений: %1", Результат.Количество());	
	
	Возврат Результат;
	
КонецФункции

Функция НормализованныйТекстОшибки(Знач ТекстОшибки)
	
	Возврат СокрЛП(НРег(ТекстОшибки));
	
КонецФункции

Функция НачатьЗаписьОтчета(Знач ПредставлениеНабораТестов, Знач КоличествоОшибок, Знач КоличествоПропусков,
	Знач ДатаНачала)
	
	Лог.Отладка("ПредставлениеНабораТестов <%1>", ПредставлениеНабораТестов);
	Лог.Отладка("КоличествоОшибок <%1>", КоличествоОшибок);
	Лог.Отладка("КоличествоПропусков <%1>", КоличествоПропусков);
	
	Результат = Новый ЗаписьXML;
	Результат.УстановитьСтроку("UTF-8");
	Результат.ЗаписатьОбъявлениеXML();
	
	ВремяВыполнения = ТекущаяДата() - ДатаНачала;
	
	Результат.ЗаписатьНачалоЭлемента("testsuites");
	Результат.ЗаписатьАтрибут("name", XMLСтрока(ПредставлениеНабораТестов)); 
	
	КоличествоТестов = КоличествоОшибок + КоличествоПропусков;
	Если КоличествоТестов = 0 Тогда
		КоличествоТестов = 1;
	КонецЕсли;
	
	Результат.ЗаписатьАтрибут("tests", XMLСтрока(КоличествоТестов));
	Результат.ЗаписатьАтрибут("failures", XMLСтрока(КоличествоОшибок));
	Результат.ЗаписатьАтрибут("skipped", XMLСтрока(КоличествоПропусков));
	Результат.ЗаписатьАтрибут("time", XMLСтрока(ВремяВыполнения));
	
	Результат.ЗаписатьНачалоЭлемента("testsuite");
	Результат.ЗаписатьАтрибут("name", XMLСтрока(ПредставлениеНабораТестов));
	Результат.ЗаписатьНачалоЭлемента("properties");
	Результат.ЗаписатьКонецЭлемента(); // properties
	
	Результат.ЗаписатьНачалоЭлемента("testcase");
	Результат.ЗаписатьАтрибут("classname", XMLСтрока(ПредставлениеНабораТестов));
	Результат.ЗаписатьАтрибут("name", XMLСтрока("Все сообщения"));
	Результат.ЗаписатьАтрибут("time", XMLСтрока(ВремяВыполнения));
	Если КоличествоОшибок = 0 Тогда
		Результат.ЗаписатьАтрибут("status", "passed");	
	Иначе
		Результат.ЗаписатьАтрибут("status", "failure");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция СтруктурироватьЛог(Знач тзРезультат, Знач ГруппироватьПоМетаданным = Ложь, Знач ИсключенияОшибок = Неопределено)
	
	Результат = Новый Структура;
	Результат.Вставить("Ошибки", Новый Соответствие);
	Результат.Вставить("Предупреждения", Новый Соответствие);
	Результат.Вставить("Пропуски", Новый Соответствие); 
	
	ИмяТестСценарияПредыдущаяСтрока = "Синтаксическая проверка конфигурации";
	
	Если НЕ ГруппироватьПоМетаданным Тогда
		Результат.Ошибки.Вставить("Синтаксическая проверка конфигурации", XMLСтрока(ОбработанныйЛог));
		Возврат Результат;
	КонецЕсли;
	
	// Определяем строки для исключения из ошибок 
	// См. стандарт "Обработчики событий модуля формы, подключаемые из кода"
	// https://its.1c.ru/db/v8std#content:-2145783155:hdoc
	МассивСтрокИсключений = Новый Массив();
	МассивСтрокИсключений.Добавить(Нрег("Не обнаружено ссылок на процедуру: ""Подключаемый_"));
	МассивСтрокИсключений.Добавить(Нрег("Не обнаружено ссылок на функцию: ""Подключаемый_"));
	МассивСтрокИсключений.Добавить(Нрег("Пустой обработчик: ""Подключаемый_"));
	МассивСтрокИсключений.Добавить(Нрег("No links to function found: ""Attachable_"));
	МассивСтрокИсключений.Добавить(Нрег("No links to procedure found: ""Attachable_"));
	МассивСтрокИсключений.Добавить(Нрег("Empty handler: ""Attachable_"));
	
	Для Каждого ТекСтрока Из тзРезультат Цикл
		
		Если ИсключитьСтроку(ТекСтрока, МассивСтрокИсключений) Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяТестСценария = ИмяТестСценария(ТекСтрока);
		
		Если ПустаяСтрока(ИмяТестСценария) Тогда
			ИмяТестСценария = ИмяТестСценарияПредыдущаяСтрока;
		КонецЕсли;
		
		ДополнитьРезультатТекстомОшибки(Результат, ТекСтрока, ИмяТестСценария, ИсключенияОшибок);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

//Проверяет вхождение строк из массива в проверямой строке.
//Параметры:
//	ПроверяемаяСтрока - Строка - строка для проверки.
//	МассивСтрокИсключений - Массив - массив строк, для проверки. 
//
//Возвращаемое значение:
//	Булево - Истина, в проверяемой строке содежрится один из элементов массив.
//			 Ложь, не нашли
Функция ИсключитьСтроку(Знач ПроверяемаяСтрока, Знач МассивСтрокИсключений)
	Для каждого СтрИсключения Из МассивСтрокИсключений Цикл
		Если СтрНайти(Нрег(ПроверяемаяСтрока), СтрИсключения) > 0 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция ИмяТестСценария(Знач СтрокаЛога)
	
	Результат = "";
	
	ЧастиСтрокиЛога = СтрРазделить(СокрЛП(СтрокаЛога), " ", Ложь);
	Если ЗначениеЗаполнено(ЧастиСтрокиЛога) Тогда
		РезультатСтрока = ЧастиСтрокиЛога[0];
	КонецЕсли;
	
	Если СтрНачинаетсяС(РезультатСтрока, "{") Тогда
		
		РезультатСтрока = СтрЗаменить(РезультатСтрока, "{", "");
		РезультатСтрока = СтрЗаменить(РезультатСтрока, "}", "");
		ПозицияСкобки = СтрНайти(РезультатСтрока, "(");
		Если ПозицияСкобки > 1 Тогда
			Результат = Сред(РезультатСтрока, 1, ПозицияСкобки - 1);
		КонецЕсли;
	ИначеЕсли ЧастиСтрокиЛога.Количество() > 0 Тогда
		Результат = РезультатСтрока;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ДополнитьРезультатТекстомОшибки(Знач Результат, Знач ТекСтрока, Знач ИмяТестСценария, Знач ИсключенияОшибок)
	
	Если СледуетПропуститьОшибку(ТекСтрока, ИсключенияОшибок) Тогда
		Раздел = "Пропуски";
	Иначе
		Раздел = "Ошибки";
	КонецЕсли;
	
	Если Результат[Раздел][ИмяТестСценария] = Неопределено Тогда
		Результат[Раздел][ИмяТестСценария] = СокрЛП(ТекСтрока);
	Иначе
		Результат[Раздел][ИмяТестСценария] = СтрШаблон(
		"%1
		|%2",
		Результат[Раздел][ИмяТестСценария],
		СокрЛП(ТекСтрока));
	КонецЕсли;
	
КонецПроцедуры

Функция СледуетПропуститьОшибку(Знач ТекстОшибки, Знач ИсключенияОшибок)
	
	Если Не ЗначениеЗаполнено(ИсключенияОшибок) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого ТекИсключение Из ИсключенияОшибок Цикл
		Если СтрНайти(НормализованныйТекстОшибки(ТекстОшибки), ТекИсключение) > 0 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

//////////////////////////////////
// Из обработки 
/////////////////////////////////

Процедура КнопкаВыполнитьНажатие( Кнопка )
	
	тз = ПрочитатьТаблицуИзФайлаРезультата( ПутьКФайлуРезультата() );
	
	СоздатьФайлыПоТаблицеПроверки(тз);
	
КонецПроцедуры

Процедура ОсновныеДействияФормыПостроитьРазностныйОтчет(Кнопка)
	
	тз_стар = ПрочитатьТаблицуИзФайлаРезультата( ПутьКФайлу_СтарыйРезультат() );
	тз_стар.Колонки.Добавить("Изменение");
	тз_стар.ЗаполнитьЗначения(1, "Изменение" );
	
	тз = ПрочитатьТаблицуИзФайлаРезультата( ПутьКФайлу_НовыйРезультат() );
	тз.Колонки.Добавить("Изменение");
	тз.ЗаполнитьЗначения(-1, "Изменение" );
	
	Для каждого цСтрока Из тз_стар Цикл
		
		ЗаполнитьЗначенияСвойств( тз.Добавить(), цСтрока );
		
	КонецЦикла;
	
	тз.Свернуть( "Тип,Проект,Метаданные,Положение,Описание" , "Изменение" );
	
	Для каждого цСтрока Из тз Цикл
		
		Если цСтрока.Изменение = 0 Тогда
			
			// есть и в старой и в новой таблице
			цСтрока.Тип = "Пропущено";
			
		ИначеЕсли цСтрока.Изменение > 0 Тогда
			
			// есть только в старой
			цСтрока.Тип = "Исправлено";
			
		Иначе
			
			// Внесли новую ошибку
			
		КонецЕсли;
		
	КонецЦикла;
	
	СоздатьФайлыПоТаблицеПроверки(тз);
	
КонецПроцедуры

Функция ПрочитатьТаблицуИзФайлаРезультата( Знач пПутьКФайлу )
	
	тз = Новый ТаблицаЗначений;
	тз.Колонки.Добавить( "ДатаОбнаружения" );
	тз.Колонки.Добавить( "Тип" );
	тз.Колонки.Добавить( "Проект" );
	тз.Колонки.Добавить( "Метаданные" );
	тз.Колонки.Добавить( "Положение" );
	тз.Колонки.Добавить( "Описание" );
	
	ЧтениеТекста = Новый ЧтениеТекста( пПутьКФайлу, КодировкаТекста.UTF8 );
	
	ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
	
	Пока Не ПрочитаннаяСтрока = Неопределено Цикл
		
		Если ПустаяСтрока( ПрочитаннаяСтрока ) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		компонентыСтроки = СтрРазделить( ПрочитаннаяСтрока, "	" );
		
		новСтрока = тз.Добавить();
		
		Для ц = 0 По 4 Цикл
			
			новСтрока[ц] = компонентыСтроки[ц];
			
		КонецЦикла;
		
		// В описании могут быть и табы, по которым делим
		
		Для ц = 5 По компонентыСтроки.ВГраница() Цикл
			
			Если ЗначениеЗаполнено( новСтрока.Описание ) Тогда
				
				новСтрока.Описание = новСтрока.Описание + "	";
				
			Иначе
				
				новСтрока.Описание = "";
				
			КонецЕсли;
			
			новСтрока.Описание = новСтрока.Описание + компонентыСтроки[ц];
			
		КонецЦикла;
		
		ПрочитаннаяСтрока = ЧтениеТекста.ПрочитатьСтроку();
		
	КонецЦикла;
	
	Возврат тз;
	
КонецФункции

Процедура СоздатьФайлыПоТаблицеПроверки(Знач пТаблицаПроверки)
	
	УдалитьФайлы( ПапкаСОтчетомАллюр(), "*.json" );
	
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON( , Символы.Таб );
	
	Для каждого цСтрока Из пТаблицаПроверки Цикл
		
		СтруктураВыгрузки           = ПолучитьОписаниеСценарияАллюр2();
		СтруктураВыгрузки.name      = цСтрока.Метаданные + ". " + цСтрока.Положение + ": " + цСтрока.Описание;
		СтруктураВыгрузки.fullName  = СтруктураВыгрузки.name;
		СтруктураВыгрузки.historyId = цСтрока.Метаданные + ". " + цСтрока.Положение + ": " + цСтрока.Описание;
		СтруктураВыгрузки.Вставить( "description", цСтрока.Описание );
		
		Если цСтрока.Тип = "Ошибка" Тогда
			
			СтруктураВыгрузки.status = "failed";
			
		ИначеЕсли цСтрока.Тип = "Предупреждение" Тогда
			
			СтруктураВыгрузки.status = "broken";
			
		ИначеЕсли цСтрока.Тип = "Пропущено" Тогда
			
			СтруктураВыгрузки.status = "skipped";
			
		ИначеЕсли цСтрока.Тип = "Исправлено" Тогда
			
			СтруктураВыгрузки.status = "passed";
			
		КонецЕсли;
		
		структ = Новый Структура( "name,value", "package", цСтрока.Метаданные );
		СтруктураВыгрузки.labels.Добавить( структ );
		
		Для каждого цКонтекст Из ПолучитьКонтексты( цСтрока.Описание ) Цикл
			
			структ = Новый Структура( "name,value", "tag", цКонтекст );
			СтруктураВыгрузки.labels.Добавить( структ );
			
		КонецЦикла;
		
		структ = Новый Структура( "name,value", "story", ОписаниеФункциональности( цСтрока.Описание ) );
		СтруктураВыгрузки.labels.Добавить( структ );
		
		РеальноеИмяФайла = ПапкаСОтчетомАллюр() + "" + СтруктураВыгрузки.uuid + "-result.json";
		
		ЗаписьJSON = Новый ЗаписьJSON;
		
		ЗаписьJSON.УстановитьСтроку( ПараметрыЗаписиJSON );
		ЗаписьJSON.ОткрытьФайл( РеальноеИмяФайла, , , ПараметрыЗаписиJSON );
		
		ЗаписатьJSON( ЗаписьJSON, СтруктураВыгрузки );
		ЗаписьJSON.Закрыть();
		
	КонецЦикла;
	
	СоздатьФайлКатегорий();

КонецПроцедуры

Процедура СоздатьФайлКатегорий()
	
	ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON( , Символы.Таб );
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку( ПараметрыЗаписиJSON );
	ЗаписьJSON.ОткрытьФайл( ПапкаСОтчетомАллюр() + "categories.json", , , ПараметрыЗаписиJSON );
	
	категории = Новый Массив;
	
	массивСтатусов = Новый Массив;
	массивСтатусов.Добавить( "failed" );
	структ = Новый Структура( "name,matchedStatuses", "Ошибка", массивСтатусов );
	категории.Добавить( структ );
	
	массивСтатусов = Новый Массив;
	массивСтатусов.Добавить( "broken" );
	структ = Новый Структура( "name,matchedStatuses", "Предупреждение", массивСтатусов );
	категории.Добавить( структ );
	
	массивСтатусов = Новый Массив;
	массивСтатусов.Добавить( "skipped" );
	структ = Новый Структура( "name,matchedStatuses", "Пропущено", массивСтатусов );
	категории.Добавить( структ );
	
	массивСтатусов = Новый Массив;
	массивСтатусов.Добавить( "passed" );
	структ = Новый Структура( "name,matchedStatuses", "Исправлено", массивСтатусов );
	категории.Добавить( структ );
	
	
	ЗаписатьJSON( ЗаписьJSON, категории );
	ЗаписьJSON.Закрыть();

КонецПроцедуры

Функция ПолучитьКонтексты( Знач пОписание )
	
	начало = СтрНайти( пОписание, "[" );
	конец  = СтрНайти( пОписание, "]", НаправлениеПоиска.СКонца );
	
	Если начало < конец
		И конец > 0 Тогда
		
		стрКонтексты = Сред( пОписание, начало + 1, конец - начало -1 );
		
		Возврат СтрРазделить( стрКонтексты, "," );
		
	Иначе
		
		Возврат Новый Массив;
		
	КонецЕсли;
	
КонецФункции

Функция ОписаниеФункциональности( Знач пОписание )
	
	начало = СтрНайти( пОписание, "[" );
	
	Если начало > 0 Тогда
		
		описаниеБезКонтекста = Лев( пОписание, начало - 1 );
		
	Иначе
		
		описаниеБезКонтекста = пОписание;
		
	КонецЕсли;
	
	ПозицияКавычки = СтрНайти( описаниеБезКонтекста, """" );
	
	Пока ПозицияКавычки > 0 Цикл
		
		ПозицияЗакрывающейКавычки = СтрНайти( Сред( описаниеБезКонтекста, ПозицияКавычки + 1 ), """" ) + ПозицияКавычки;
		
		Если ПозицияЗакрывающейКавычки = 0 Тогда
			
			Прервать;
			
		КонецЕсли;
		
		описаниеБезКонтекста = Лев( описаниеБезКонтекста, ПозицияКавычки - 1 ) + "<>" + Сред( описаниеБезКонтекста, ПозицияЗакрывающейКавычки + 1 );
		ПозицияКавычки       = СтрНайти( описаниеБезКонтекста, """" );
		
	КонецЦикла;
	
	ПозицияКавычки = СтрНайти( описаниеБезКонтекста, "'" );
	
	Пока ПозицияКавычки > 0 Цикл
		
		ПозицияЗакрывающейКавычки = СтрНайти( Сред( описаниеБезКонтекста, ПозицияКавычки + 1 ), "'" ) + ПозицияКавычки;
		
		Если ПозицияЗакрывающейКавычки = 0 Тогда
			
			Прервать;
			
		КонецЕсли;
		
		описаниеБезКонтекста = Лев( описаниеБезКонтекста, ПозицияКавычки - 1 ) + "<>" + Сред( описаниеБезКонтекста, ПозицияЗакрывающейКавычки + 1 );
		ПозицияКавычки       = СтрНайти( описаниеБезКонтекста, "'" );
		
	КонецЦикла;
	
	начало = СтрНайти( пОписание, ":", НаправлениеПоиска.СКонца );
	
	Если начало > 0 Тогда
		
		описаниеБезКонтекста = СокрЛП( Лев( описаниеБезКонтекста, начало - 1 ) );
		
	КонецЕсли;
	
	Возврат СокрЛП( описаниеБезКонтекста );
	
КонецФункции

Функция ПолучитьОписаниеСценарияАллюр2()
	
	GUID                = Новый УникальныйИдентификатор();
	СтруктураРезультата = Новый Структура(); //"uuid, historyId, name, status, parameters, labels, links, attachments");
	СтруктураРезультата.Вставить( "uuid", Строка( GUID ) );
	СтруктураРезультата.Вставить( "historyId", Неопределено );
	СтруктураРезультата.Вставить( "name", Неопределено );
	СтруктураРезультата.Вставить( "fullName", Неопределено );
	СтруктураРезультата.Вставить( "start", Неопределено );
	СтруктураРезультата.Вставить( "stop", Неопределено );
	СтруктураРезультата.Вставить( "statusDetails", Новый Структура( "known, muted,flaky", Ложь, Ложь, Ложь ) );
	СтруктураРезультата.Вставить( "status", Неопределено );
	СтруктураРезультата.Вставить( "stage", "finished" ); // Внятного описания, зачем это в каждом сценарии нет.
	СтруктураРезультата.Вставить( "steps", Новый Массив() );
	СтруктураРезультата.Вставить( "parameters", Новый Массив() );
	СтруктураРезультата.Вставить( "labels", Новый Массив() );
	СтруктураРезультата.Вставить( "links", Новый Массив() );
	СтруктураРезультата.Вставить( "attachments", Новый Массив() );
	СтруктураРезультата.Вставить( "description", Неопределено );
	
	Возврат СтруктураРезультата;
	
КонецФункции

Функция ПутьКФайлуРезультата()
	
	Возврат "D:\validation-result.txt";
	
КонецФункции

Функция ПутьКФайлу_СтарыйРезультат()
	
	Возврат "D:\validation-result_old.txt";
	
КонецФункции

Функция ПутьКФайлу_НовыйРезультат()
	
	Возврат "D:\validation-result_new.txt";
	
КонецФункции

Функция ПапкаСОтчетомАллюр()
	
	Возврат "c:\Program Files (x86)\Jenkins\workspace\Тест создания отчета по проверке\allure-results\";
	
КонецФункции


